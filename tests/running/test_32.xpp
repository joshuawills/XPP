// Implicit calling of destructors

pub extern printf(i8*, ...) i32;
extern malloc(i64) void*;
extern calloc(i64, i64) void*;
extern free(void*) void;
extern realloc(void*, i64) void*;

let SECTION_SIZE: i64 = 100;

class Foo {
    mut bar: i64;
    pub Foo() {
        bar = 21;
    }

    destructor {
        printf("Calling foo destructor!\n");
    }
}

class Foo2 {
    mut bar: i64;
    pub Foo2() {
        bar = 21;
    }

}

pub class IntList {
	mut arr: i64*;
	pub mut len: i64;
	mut section_size: i64;
    x: Foo;
    y: Foo2;
	
	pub IntList() {
        len = 0;
        section_size = SECTION_SIZE;
        arr = calloc(section_size, size_of(i64));
        x = Foo();
        y = Foo2();
    }

    pub IntList(v: IntList*) {
        printf("Calling copy constructor!\n");
        len = v->size();
        section_size = v->size();
        arr = new i64[section_size];
        loop i in len {
            arr[i] = v->at(i);
        }
        x = Foo();
        y = Foo2();
    }

    destructor {
        printf("Calling IntList destructor!\n");
        delete arr;
    }

    pub mut fn append(val: i64) void {
        if len != 0 and len % section_size == 0 {
            let num_iterations = len / section_size;
            let size: i64 = (num_iterations + 1) * section_size * size_of(i64);
            arr = realloc(arr, size);
        }
        arr[len++] = val;
    }

    pub fn at(v: i64) i64 {
        return arr[v];
    }

    pub fn print() void {
        loop i in len {
            printf("%d\n", arr[i]);
        }
    }

    pub fn size() i64 {
        return len;
    }

}

fn take_in_int_list(x: IntList) void {
	x.print();
}

fn take_in_int_list_p(x: IntList*) void {
	x->print();
}

fn main() void {
    let mut list = IntList();

    loop i in 25 {
        list.append(i);
    }

    take_in_int_list(list);
    take_in_int_list_p(&list);

}
